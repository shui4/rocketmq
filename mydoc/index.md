## 第一章

模块介绍

```
rocketmq
├── acl：权限控制模块
├── broker：broker模块（broker启动进程）
├── client：消息客户端，包含消息生产者和消费消费者相关类
├── common：公共包
├── dev：开发者信息（非源码）
├── distribution：打包分发目录（非源码）
├── exmpale：RocketMQ示例代码
├── filter：消息过滤相关基础类
├── logging：日志实现相关类
├── namesrv：NameServer实现相关类（NameServer启动进程）
├── openmessaging：消息开放标准，已发布
├── remoting：远程通行模块，基于Netty
├── srvutil：服务器工具类
├── store：消息存储实现类
├── style：checkstyle相关实现
├── test：测试相关类
└── tools：工具类，监控命令相关实现类
```

设计目标

1. 架构模式
2. 顺序消费
3. 消息过滤
4. 消息存储
5. 消息高可用性
6. 消息到达（消费）低延迟
7. 确保消息必须被消费一次
8. 回溯消息
9. 消息堆积
10. 定时消息
11. 消息重试机制

## 第二章-RocketMQ路由中心

#### NameServer架构设计

![ch2](img/ch2.png)

## 第三章-RocketMQ发送

普通消息3种实现：

- 可靠同步发送：发送消息等待响应。
- 可靠异步发送：发送消息，不阻塞，服务端响应之后，在另外的线程执行。
- 单向发送：只发，不管。

本章内容：

- RocketMQ消息结构。
- 消息生产者启动流程。
- 消息发送过程。
- 批量消息发送。

RocketMQ消息发送需要考虑3个问题：

- 消息队列如何进行负载？
- 消息发送如何实现高可用？
- 批量消息发送如何实现一致性？

消息发送高可用设计

- 1）消息发送重试机制RocketMQ在消息发送时如果出现失败，默认会重试两次。

- 2）故障规避机制当消息第一次发送失败时，如果下一次消息还是发送到刚刚失败

  的Broker上，其消息发送大概率还是会失败，因此为了保证重试的可靠性，在重试时会尽量避开刚刚接收失败的Broker，而是选择其他Broker上的队列进行发送，从而提高消息发送的成功率。