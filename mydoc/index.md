## 第一章

模块介绍

```
rocketmq
├── acl：权限控制模块
├── broker：broker模块（broker启动进程）
├── client：消息客户端，包含消息生产者和消费消费者相关类
├── common：公共包
├── dev：开发者信息（非源码）
├── distribution：打包分发目录（非源码）
├── exmpale：RocketMQ示例代码
├── filter：消息过滤相关基础类
├── logging：日志实现相关类
├── namesrv：NameServer实现相关类（NameServer启动进程）
├── openmessaging：消息开放标准，已发布
├── remoting：远程通行模块，基于Netty
├── srvutil：服务器工具类
├── store：消息存储实现类
├── style：checkstyle相关实现
├── test：测试相关类
└── tools：工具类，监控命令相关实现类
```

设计目标

1. 架构模式
2. 顺序消费
3. 消息过滤
4. 消息存储
5. 消息高可用性
6. 消息到达（消费）低延迟
7. 确保消息必须被消费一次
8. 回溯消息
9. 消息堆积
10. 定时消息
11. 消息重试机制

## 第二章

#### NameServer架构设计

- 生产者在发送消息之前，会从NameServer获取Broker服务器的地址列表，通过负载均衡算法选择一台服务器，进行消息发送。
- 每台Broker服务与NameServer保持长连接，间隔 10秒检测Broker是否存活，如果监测到不存活，则从路由注册表中将其移除，但是路由变化不会马上通知消息生产者。──其这样做的目的是为了降低NameServer实现的复杂性，因此需要在消息发送端提供容错机制保证消息的高可用性。 
- NameServer通过部署多台实现高可用性，但它们之前不会互相通信，所以可能会出现数据不完全相同的情况，但对于消息生产者来说不会造成大的影响，无法就是短期消息发送不均衡。



